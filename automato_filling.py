# BASIC PACKAGES
import ast
import re
import croniter
import numpy as np
import pandas as pd
from datetime import date, datetime, timedelta
from oauth2client.service_account import ServiceAccountCredentials


# INITIALIZE PYGSHEETS
import pygsheets, httplib2
gs = pygsheets.authorize(service_file='service_account_token.json')

# INITIALIZE QUERYRUNNER
from queryrunner_client import Client
client = Client(user_email='petrica.mercorea@uber.com')

dow = date.today().weekday()

file = gs.open_by_key('1NlDNmho_lp4LLSWjUDJRwGnScvazuO5bTvVdGHBxdXw')
form = file.worksheet_by_title('Form Responses 1').get_as_df()
form.head()

date_enabled = str(date.today())# - timedelta(days = dow))
date_enabled

#filtered = tab.loc['Timestamp'] = str(date.today())
filtered = form.loc[tabs['Timestamp'] == date_enabled]
filtered.reset_index(drop=True)

file = gs.open_by_key('1NlDNmho_lp4LLSWjUDJRwGnScvazuO5bTvVdGHBxdXw')
output = file.worksheet_by_title('today')
output.set_dataframe(filtered, (1,1), copy_index=False, copy_head=True, fit=True)

file2 = gs.open_by_key('1NlDNmho_lp4LLSWjUDJRwGnScvazuO5bTvVdGHBxdXw')
today = file.worksheet_by_title('today').get_as_df()
today.head()

df2 = pd.DataFrame(columns= ['automation_name','geography','from_taishan','query_id','uuid_column','static',
                            'content_column','cadence','day_of_next_run','categorization','weekly_hours_saved',
                            'biz_priority','owner','date_enabled','active','expires','parameters',
                            'max_uuids_per_execution','type_of_action','automation_log_sheet',
                            'final_destination_output','supporting_docs','freeform_explanation','error','validation'])

for i, row in enumerate(tab.values):
    automation_name = tab.loc[i, 'Automation name']
    sub_region = tab.loc[i,'Which subregion(s) is this for?']
    country = tab.loc[i, 'Which country is this for?']
    from_taishan = 'FALSE'
    query_id = tab.loc[i,'Query URL'].split('/r/')[1].split('/run/')[0]

#########################################################################

    # Validation (uuid_column, content_column, and max_uuid per execution)

    execution = client.execute_report(query_id) #, params)
    data = pd.DataFrame(execution.fetchall())
    length = len(data.index)

#########################################################################

    # uuid_column
    try:
        uuid_column = str(list(data.columns.values)[0]).lower()
    except:
        uuid_column = str(tab.loc[i,'UUID column']).lower()

    # static
    if str(tab.loc[i,'Is this a static automation? ']).lower() == 'yes':
        static = 'TRUE'
    else:
        static = 'FALSE'

    # content  --- to review

    if static == 'FALSE':
        try:
            content_column = str(list(data.columns.values)[1]).lower()
        except:
            content_column = str(tab.loc[i,'Content column (if automation is dynamic)']).lower()
    else:
        content_column =' '


    # cadence
    if tab.loc[i, 'Cadence - how often should your automation run?  [Morning (08:00)]'] != '':
        cadence = '0 8 * * ' + str(tab.loc[i, 'Cadence - how often should your automation run?  [Morning (08:00)]']).lower()
    elif tab.loc[i, 'Cadence - how often should your automation run?  [Afternoon (13:00)]'] != '':
        cadence = '0 13 * * ' + str(tab.loc[i, 'Cadence - how often should your automation run?  [Afternoon (13:00)]']).lower()
    elif tab.loc[i, 'Cadence - how often should your automation run?  [Evening (18:00)]'] != '':
        cadence = '0 19 * * ' + str(tab.loc[i, 'Cadence - how often should your automation run?  [Evening (18:00)]']).lower()
    else:
        cadence = '30 10 * * *'

    day_of_next_run = ' ' # automatically generated by automato main script
    categorization = tab.loc[i,'Categorization']
    weekly_hours_saved = tab.loc[i,'Weekly hours saved']
    biz_priority = str(re.findall(r'\d+', tab.loc[i,'Business priority'])[0])
    owner = tab.loc[i,'Email Address']
    date_enabled = str(date.today())
    active = ' '  # automatically generated by automato main script
    expires = tab.loc[i,'Expiry date']
    parameters = tab.loc[i,'Action content (i.e. tag or Trait UUID) to apply (if automation is static)']
    max_uuids_per_execution = (tab.loc[i,'Maximum actioned users per run'])
    type_of_action = tab.loc[i,'Type of action'].split(' (')[0]
    automation_log_sheet = ' ' # automatically generated by automato main script
    final_destination_output = tab.loc[i,'Final destination / output']
    supporting_docs = tab.loc[i,'URL to supporting document (Eg. process/project doc)']
    freeform_explanation = tab.loc[i,'Freeform explanation - Why do you need it?']
    error = ' ' # I guess this is past run


    #validation - this part is for validation purposes only, can be skipped from the output file
    try:
        if int(max_uuids_per_execution) >= length:
            validation = 'True'
        else:
            validation = 'False'
    except:
        validation = 'False'


    data=np.array([automation_name,geography,from_taishan,query_id,uuid_column,static,content_column,
                    cadence,day_of_next_run,categorization,weekly_hours_saved,biz_priority,owner,
                    date_enabled,active,expires,parameters,max_uuids_per_execution,type_of_action,
                    automation_log_sheet,final_destination_output,supporting_docs,
                    freeform_explanation,error,validation])

    df2 = df2.append(pd.DataFrame([data], columns= ['automation_name','geography','from_taishan','query_id',
                                                    'uuid_column','static','content_column','cadence',
                                                    'day_of_next_run','categorization','weekly_hours_saved',
                                                    'biz_priority','owner','date_enabled','active','expires',
                                                    'parameters','max_uuids_per_execution','type_of_action',
                                                    'automation_log_sheet','final_destination_output',
                                                    'supporting_docs','freeform_explanation','error','validation'])
                     ,ignore_index=True)

df_validated = df2.loc[df2['validation'] == 'True']
df_validated.reset_index(drop=True)
del df_validated['validation']
file = gs.open_by_key('1NlDNmho_lp4LLSWjUDJRwGnScvazuO5bTvVdGHBxdXw')
output = file.worksheet_by_title('Output')
output.set_dataframe(df_validated, (1,1), copy_index=False, copy_head=True, fit=True)

# to be reviewed
df_review = df2.loc[df2['validation'] == 'False']
df_review.reset_index(drop=True)
del df_review['validation']
file = gs.open_by_key('1NlDNmho_lp4LLSWjUDJRwGnScvazuO5bTvVdGHBxdXw')
output = file.worksheet_by_title('To Be Reviewed')
output.set_dataframe(df_review, (1,1), copy_index=False, copy_head=True, fit=True)

validated_html = df_validated.to_html()
review_html = df_review.to_html()

from pretty_html_table import build_table
output = build_table(df_review, 'blue_light')

from email.mime.text import MIMEText
import smtplib


def send_mail(body):

    message = MIMEMultipart()
    message['Subject'] = 'Automato Filling run!' + date_enable)
    message['From'] = '<no-reply@uber.com'
    message['To'] = '<petrica.mercorea@uber.com'

    body_content = body
    message.attach(MIMEText(body_content, "html"))
    msg_body = message.as_string()

    server = smtplib.SMTP('localhost:25')
    server.sendmail(message['From'], message['To'], msg_body)
    server.quit()

def send_automato_list():
    gdp_data = df_review
    output = build_table(gdp_data, 'blue_light')
    send_mail(output)
    return "Mail sent successfully."

send_country_list()
